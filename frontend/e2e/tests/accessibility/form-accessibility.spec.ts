/**
 * Form Accessibility Tests
 * 
 * Tests comprehensive form accessibility including:
 * - Label associations and descriptions
 * - Error handling and validation
 * - Required field indicators
 * - Fieldset and legend usage
 * - Autocomplete attributes
 * - Input purposes and formats
 * - Accessible form submission
 * 
 * UOL-44.19: Comprehensive Accessibility E2E Tests
 */

import { test, expect, Page, Locator } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';
import { AccessibilityHelper } from '../../helpers/accessibility.helper';
import { AccessibilityPage } from '../../pages/AccessibilityPage';

interface FormTest {
  pagePath: string;
  formName: string;
  expectedFields: string[];
  requiredFields: string[];
}

interface ValidationTest {
  fieldType: string;
  invalidValue: string;
  validValue: string;
  expectedError: RegExp;
}

test.describe('Form Accessibility Tests', () => {
  let accessibilityHelper: AccessibilityHelper;
  let accessibilityPage: AccessibilityPage;

  test.beforeEach(async ({ page }) => {
    accessibilityHelper = new AccessibilityHelper(page);
    accessibilityPage = new AccessibilityPage(page);
    
    await accessibilityHelper.configureAxe();
  });

  test.describe('Label Associations', () => {
    test('should have proper label associations for all form controls', async ({ page }) => {
      const formPages = ['/login', '/register', '/profile'];
      
      for (const formPage of formPages) {
        await page.goto(formPage);
        await accessibilityPage.waitForPageLoad();
        
        // Run axe-core label checks\n        const results = await new AxeBuilder({ page })\n          .withRules([\n            'label',\n            'form-field-multiple-labels',\n            'label-title-only',\n            'label-content-name-mismatch'\n          ])\n          .analyze();\n          \n        expect(results.violations, `Page ${formPage} should have proper form labels`).toEqual([]);\n        \n        // Manual verification of all form controls\n        const formControls = await page.locator('input, select, textarea').all();\n        \n        for (const control of formControls) {\n          const controlType = await control.getAttribute('type') || 'text';\n          const controlId = await control.getAttribute('id');\n          const controlName = await control.getAttribute('name');\n          \n          // Skip hidden inputs and submit buttons\n          if (controlType === 'hidden' || controlType === 'submit') continue;\n          \n          // Check for label association\n          const hasLabel = await control.evaluate((el) => {\n            const input = el as HTMLInputElement;\n            \n            // Method 1: Label with 'for' attribute\n            if (input.id) {\n              const label = document.querySelector(`label[for=\"${input.id}\"]`);\n              if (label) return true;\n            }\n            \n            // Method 2: Input inside label\n            const parentLabel = input.closest('label');\n            if (parentLabel) return true;\n            \n            // Method 3: aria-label\n            if (input.getAttribute('aria-label')) return true;\n            \n            // Method 4: aria-labelledby\n            if (input.getAttribute('aria-labelledby')) {\n              const labelledBy = input.getAttribute('aria-labelledby')!;\n              const referencedElements = labelledBy.split(' ');\n              return referencedElements.every(id => document.getElementById(id));\n            }\n            \n            // Method 5: title attribute (not recommended but valid)\n            if (input.getAttribute('title')) return true;\n            \n            return false;\n          });\n          \n          expect(\n            hasLabel, \n            `Form control ${controlType} with name=\"${controlName}\" should have label association on ${formPage}`\n          ).toBeTruthy();\n          \n          // Verify accessible name is meaningful\n          const accessibleName = await accessibilityHelper.getAccessibleName(control);\n          expect(\n            accessibleName.length,\n            `Form control should have meaningful accessible name on ${formPage}`\n          ).toBeGreaterThan(0);\n        }\n      }\n    });\n\n    test('should have unique and descriptive labels', async ({ page }) => {\n      const formPages = ['/register', '/profile'];\n      \n      for (const formPage of formPages) {\n        await page.goto(formPage);\n        \n        const formControls = await page.locator('input, select, textarea').all();\n        const labelTexts = new Set<string>();\n        \n        for (const control of formControls) {\n          const controlType = await control.getAttribute('type');\n          \n          if (controlType === 'hidden' || controlType === 'submit') continue;\n          \n          const accessibleName = await accessibilityHelper.getAccessibleName(control);\n          \n          if (accessibleName.length > 0) {\n            // Check for duplicate labels (should be avoided)\n            if (labelTexts.has(accessibleName)) {\n              console.warn(`Duplicate label found on ${formPage}: \"${accessibleName}\"`);\n            }\n            labelTexts.add(accessibleName);\n            \n            // Label should be descriptive (avoid generic terms)\n            const genericLabels = ['input', 'field', 'textbox', 'text', 'enter'];\n            const isGeneric = genericLabels.some(generic => \n              accessibleName.toLowerCase().trim() === generic\n            );\n            \n            expect(\n              isGeneric,\n              `Label \"${accessibleName}\" should be descriptive, not generic`\n            ).toBeFalsy();\n          }\n        }\n      }\n    });\n\n    test('should associate labels with the correct control when multiple exist', async ({ page }) => {\n      await page.goto('/profile');\n      \n      // Look for cases where multiple controls might have similar labels\n      const emailInputs = await page.locator('input[type=\"email\"]').all();\n      \n      if (emailInputs.length > 1) {\n        for (const emailInput of emailInputs) {\n          const label = await accessibilityHelper.getAccessibleName(emailInput);\n          const inputId = await emailInput.getAttribute('id');\n          \n          expect(\n            label.length,\n            `Each email input should have a distinct label`\n          ).toBeGreaterThan(0);\n          \n          // Verify the label is actually associated with this specific input\n          if (inputId) {\n            const associatedLabel = await page.locator(`label[for=\"${inputId}\"]`).first();\n            \n            if (await associatedLabel.count() > 0) {\n              const labelText = await associatedLabel.textContent();\n              expect(\n                labelText?.trim(),\n                `Label should be associated with correct input`\n              ).toBe(label.trim());\n            }\n          }\n        }\n      }\n    });\n  });\n\n  test.describe('Required Field Indicators', () => {\n    test('should properly indicate required fields', async ({ page }) => {\n      const formPages = ['/login', '/register'];\n      \n      for (const formPage of formPages) {\n        await page.goto(formPage);\n        \n        const requiredFields = await accessibilityPage.getRequiredFields();\n        \n        for (const field of requiredFields) {\n          // Check programmatic indication\n          const hasRequiredAttr = await field.getAttribute('required');\n          const hasAriaRequired = await field.getAttribute('aria-required');\n          \n          expect(\n            hasRequiredAttr !== null || hasAriaRequired === 'true',\n            'Required fields should have required or aria-required attribute'\n          ).toBeTruthy();\n          \n          // Check visual indication in label\n          const fieldId = await field.getAttribute('id');\n          const fieldName = await field.getAttribute('name');\n          \n          if (fieldId) {\n            const associatedLabel = await page.locator(`label[for=\"${fieldId}\"]`).first();\n            \n            if (await associatedLabel.count() > 0) {\n              const labelText = await associatedLabel.textContent();\n              const labelHtml = await associatedLabel.innerHTML();\n              \n              // Should have some visual indicator (*, required, etc.)\n              const hasVisualIndicator = labelText?.includes('*') ||\n                                       labelText?.toLowerCase().includes('required') ||\n                                       labelHtml.includes('required') ||\n                                       labelHtml.includes('*');\n              \n              expect(\n                hasVisualIndicator,\n                `Required field label \"${labelText}\" should have visual indicator`\n              ).toBeTruthy();\n            }\n          }\n        }\n        \n        // Should have general instructions about required fields\n        const hasRequiredInstruction = await page.locator(\n          'text=\"* indicates required field\", text=\"required fields\", [aria-describedby], .form-help'\n        ).count();\n        \n        if (requiredFields.length > 0) {\n          expect(\n            hasRequiredInstruction,\n            `Page ${formPage} should explain required field indicators`\n          ).toBeGreaterThan(0);\n        }\n      }\n    });\n\n    test('should maintain required field indicators across states', async ({ page }) => {\n      await page.goto('/register');\n      \n      const requiredFields = await accessibilityPage.getRequiredFields();\n      \n      for (const field of requiredFields.slice(0, 3)) {\n        // Test initial state\n        const initialRequired = await field.getAttribute('aria-required') || \n                               await field.getAttribute('required');\n        \n        // Focus the field\n        await field.focus();\n        await page.waitForTimeout(200);\n        \n        const focusedRequired = await field.getAttribute('aria-required') || \n                               await field.getAttribute('required');\n        \n        expect(\n          focusedRequired,\n          'Required indicator should persist when field is focused'\n        ).toBe(initialRequired);\n        \n        // Fill the field\n        const fieldType = await field.getAttribute('type');\n        \n        if (fieldType === 'email') {\n          await field.fill('test@example.com');\n        } else if (fieldType === 'password') {\n          await field.fill('password123');\n        } else {\n          await field.fill('test value');\n        }\n        \n        await page.waitForTimeout(200);\n        \n        const filledRequired = await field.getAttribute('aria-required') || \n                              await field.getAttribute('required');\n        \n        expect(\n          filledRequired,\n          'Required indicator should persist when field is filled'\n        ).toBe(initialRequired);\n      }\n    });\n  });\n\n  test.describe('Error Handling and Validation', () => {\n    test('should provide accessible error messages', async ({ page }) => {\n      await page.goto('/login');\n      \n      // Submit form without filling required fields\n      const submitButton = await page.locator('button[type=\"submit\"], input[type=\"submit\"]').first();\n      await submitButton.click();\n      await page.waitForTimeout(1000);\n      \n      const errorMessages = await accessibilityPage.getErrorMessages();\n      \n      for (const errorMessage of errorMessages) {\n        // Error should be visible\n        await expect(errorMessage).toBeVisible();\n        \n        // Error should have proper role or live region\n        const role = await errorMessage.getAttribute('role');\n        const ariaLive = await errorMessage.getAttribute('aria-live');\n        \n        const isAccessible = role === 'alert' ||\n                            ariaLive === 'assertive' ||\n                            ariaLive === 'polite';\n        \n        expect(isAccessible, 'Error messages should be announced to screen readers').toBeTruthy();\n        \n        // Error should be associated with the relevant field\n        const errorId = await errorMessage.getAttribute('id');\n        \n        if (errorId) {\n          const associatedField = await page.locator(`[aria-describedby*=\"${errorId}\"]`).first();\n          \n          if (await associatedField.count() > 0) {\n            expect(\n              await associatedField.count(),\n              'Error message should be associated with form field'\n            ).toBeGreaterThan(0);\n          }\n        }\n        \n        // Error text should be meaningful\n        const errorText = await errorMessage.textContent();\n        expect(\n          errorText?.trim().length,\n          'Error messages should have meaningful text'\n        ).toBeGreaterThan(0);\n        \n        // Should not be generic error\n        const genericErrors = ['error', 'invalid', 'wrong', 'bad'];\n        const isGeneric = genericErrors.some(generic => \n          errorText?.toLowerCase().trim() === generic\n        );\n        \n        expect(\n          isGeneric,\n          `Error message \"${errorText}\" should be specific, not generic`\n        ).toBeFalsy();\n      }\n    });\n\n    test('should provide error suggestions and corrections', async ({ page }) => {\n      await page.goto('/register');\n      \n      const validationTests: ValidationTest[] = [\n        {\n          fieldType: 'email',\n          invalidValue: 'invalid-email',\n          validValue: 'user@example.com',\n          expectedError: /email|format|@|example/i\n        },\n        {\n          fieldType: 'password',\n          invalidValue: '123',\n          validValue: 'SecurePass123!',\n          expectedError: /password|length|character|requirement/i\n        },\n        {\n          fieldType: 'tel',\n          invalidValue: 'abc123',\n          validValue: '+1234567890',\n          expectedError: /phone|number|format|digit/i\n        }\n      ];\n      \n      for (const test of validationTests) {\n        const field = await page.locator(`input[type=\"${test.fieldType}\"]`).first();\n        \n        if (await field.count() > 0) {\n          // Enter invalid value\n          await field.fill(test.invalidValue);\n          await field.blur();\n          await page.waitForTimeout(500);\n          \n          // Look for error message\n          const fieldId = await field.getAttribute('id');\n          const fieldName = await field.getAttribute('name');\n          \n          let errorMessage = null;\n          \n          // Try to find associated error message\n          if (fieldId) {\n            const describedBy = await field.getAttribute('aria-describedby');\n            \n            if (describedBy) {\n              const errorIds = describedBy.split(' ');\n              \n              for (const errorId of errorIds) {\n                const errorEl = await page.locator(`#${errorId}`).first();\n                \n                if (await errorEl.count() > 0 && await errorEl.isVisible()) {\n                  errorMessage = await errorEl.textContent();\n                  break;\n                }\n              }\n            }\n          }\n          \n          // Fallback: look for nearby error messages\n          if (!errorMessage) {\n            const nearbyErrors = await field.locator('xpath=..//*[contains(@class, \"error\") or contains(@role, \"alert\")]').all();\n            \n            for (const error of nearbyErrors) {\n              if (await error.isVisible()) {\n                errorMessage = await error.textContent();\n                break;\n              }\n            }\n          }\n          \n          if (errorMessage) {\n            expect(\n              test.expectedError.test(errorMessage),\n              `Error message \"${errorMessage}\" should provide helpful guidance for ${test.fieldType} field`\n            ).toBeTruthy();\n          }\n        }\n      }\n    });\n\n    test('should clear errors when input becomes valid', async ({ page }) => {\n      await page.goto('/login');\n      \n      // Submit to trigger validation\n      const submitButton = await page.locator('button[type=\"submit\"]').first();\n      await submitButton.click();\n      await page.waitForTimeout(1000);\n      \n      // Find a required email field\n      const emailField = await page.locator('input[type=\"email\"][required], input[type=\"email\"][aria-required=\"true\"]').first();\n      \n      if (await emailField.count() > 0) {\n        // Should have error initially\n        let errorElements = await accessibilityPage.getErrorMessages();\n        const initialErrorCount = errorElements.length;\n        \n        // Fill with valid email\n        await emailField.fill('valid@example.com');\n        await emailField.blur();\n        await page.waitForTimeout(1000);\n        \n        // Errors should be cleared or reduced\n        errorElements = await accessibilityPage.getErrorMessages();\n        const finalErrorCount = errorElements.length;\n        \n        expect(\n          finalErrorCount,\n          'Error count should decrease when valid input is provided'\n        ).toBeLessThanOrEqual(initialErrorCount);\n      }\n    });\n\n    test('should handle client-side and server-side validation consistently', async ({ page }) => {\n      await page.goto('/register');\n      \n      const emailField = await page.locator('input[type=\"email\"]').first();\n      \n      if (await emailField.count() > 0) {\n        // Test client-side validation\n        await emailField.fill('invalid-email');\n        await emailField.blur();\n        await page.waitForTimeout(500);\n        \n        const clientErrorElements = await accessibilityPage.getErrorMessages();\n        \n        // Test that HTML5 validation doesn't override accessible error handling\n        const html5ValidationMessage = await emailField.evaluate((el: HTMLInputElement) => {\n          return el.validationMessage;\n        });\n        \n        if (html5ValidationMessage && clientErrorElements.length > 0) {\n          // Should have custom accessible error message, not just HTML5 validation\n          const customError = await clientErrorElements[0].textContent();\n          \n          expect(\n            customError,\n            'Should use custom accessible error messages over HTML5 validation'\n          ).not.toBe(html5ValidationMessage);\n        }\n      }\n    });\n  });\n\n  test.describe('Fieldset and Legend Usage', () => {\n    test('should use fieldsets for grouped form controls', async ({ page }) => {\n      const formPages = ['/register', '/profile'];\n      \n      for (const formPage of formPages) {\n        await page.goto(formPage);\n        \n        const fieldsets = await page.locator('fieldset').all();\n        \n        for (const fieldset of fieldsets) {\n          // Every fieldset should have a legend\n          const legend = await fieldset.locator('legend').first();\n          await expect(legend).toBeAttached();\n          \n          const legendText = await legend.textContent();\n          expect(\n            legendText?.trim().length,\n            'Fieldset legends should have descriptive text'\n          ).toBeGreaterThan(0);\n          \n          // Fieldset should contain form controls\n          const controls = await fieldset.locator('input, select, textarea').all();\n          expect(\n            controls.length,\n            'Fieldsets should contain form controls'\n          ).toBeGreaterThan(0);\n          \n          // Related controls should be logically grouped\n          const controlTypes = new Set();\n          \n          for (const control of controls) {\n            const name = await control.getAttribute('name');\n            const type = await control.getAttribute('type');\n            \n            if (name) controlTypes.add(name);\n            if (type) controlTypes.add(type);\n          }\n          \n          // Should group related fields (e.g., address fields, contact fields)\n          console.log(`Fieldset \"${legendText}\" contains ${controls.length} controls`);\n        }\n      }\n    });\n\n    test('should use fieldsets for radio button groups', async ({ page }) => {\n      await page.goto('/profile');\n      \n      const radioButtons = await page.locator('input[type=\"radio\"]').all();\n      \n      if (radioButtons.length > 0) {\n        const radioGroups = new Map<string, Locator[]>();\n        \n        // Group radio buttons by name\n        for (const radio of radioButtons) {\n          const name = await radio.getAttribute('name');\n          \n          if (name) {\n            if (!radioGroups.has(name)) {\n              radioGroups.set(name, []);\n            }\n            radioGroups.get(name)!.push(radio);\n          }\n        }\n        \n        // Each radio group should be in a fieldset\n        for (const [groupName, radios] of radioGroups) {\n          if (radios.length > 1) {\n            const firstRadio = radios[0];\n            const fieldset = await firstRadio.locator('xpath=ancestor::fieldset').first();\n            \n            expect(\n              await fieldset.count(),\n              `Radio group \"${groupName}\" should be contained in a fieldset`\n            ).toBeGreaterThan(0);\n            \n            if (await fieldset.count() > 0) {\n              const legend = await fieldset.locator('legend').first();\n              await expect(legend).toBeAttached();\n              \n              const legendText = await legend.textContent();\n              expect(\n                legendText?.trim().length,\n                `Radio group \"${groupName}\" should have descriptive legend`\n              ).toBeGreaterThan(0);\n            }\n          }\n        }\n      }\n    });\n\n    test('should use fieldsets for checkbox groups', async ({ page }) => {\n      await page.goto('/profile');\n      \n      // Look for logical checkbox groups (same name or related topics)\n      const checkboxes = await page.locator('input[type=\"checkbox\"]').all();\n      \n      if (checkboxes.length > 2) {\n        // Look for checkboxes that might be logically grouped\n        const checkboxGroups = new Map<string, Locator[]>();\n        \n        for (const checkbox of checkboxes) {\n          const name = await checkbox.getAttribute('name');\n          const id = await checkbox.getAttribute('id');\n          const label = await accessibilityHelper.getAccessibleName(checkbox);\n          \n          // Group by name or by semantic similarity\n          const groupKey = name || 'preferences'; // Default group for preferences\n          \n          if (!checkboxGroups.has(groupKey)) {\n            checkboxGroups.set(groupKey, []);\n          }\n          checkboxGroups.get(groupKey)!.push(checkbox);\n        }\n        \n        for (const [groupName, checkboxList] of checkboxGroups) {\n          if (checkboxList.length > 2) {\n            // Check if grouped in fieldset\n            const firstCheckbox = checkboxList[0];\n            const fieldset = await firstCheckbox.locator('xpath=ancestor::fieldset').first();\n            \n            if (await fieldset.count() > 0) {\n              const legend = await fieldset.locator('legend').first();\n              await expect(legend).toBeAttached();\n              \n              console.log(`Checkbox group \"${groupName}\" is properly contained in fieldset`);\n            } else {\n              console.warn(`Checkbox group \"${groupName}\" should consider using fieldset for better accessibility`);\n            }\n          }\n        }\n      }\n    });\n  });\n\n  test.describe('Autocomplete and Input Purposes', () => {\n    test('should have appropriate autocomplete attributes', async ({ page }) => {\n      const formPages = ['/login', '/register', '/profile'];\n      \n      const autocompleteTests = [\n        { type: 'email', expected: 'email' },\n        { name: 'username', expected: 'username' },\n        { name: 'password', expected: 'current-password' },\n        { name: 'new-password', expected: 'new-password' },\n        { name: 'first-name', expected: 'given-name' },\n        { name: 'last-name', expected: 'family-name' },\n        { name: 'phone', expected: 'tel' },\n        { name: 'address', expected: 'street-address' },\n        { name: 'city', expected: 'address-level2' },\n        { name: 'postal-code', expected: 'postal-code' },\n        { name: 'country', expected: 'country' }\n      ];\n      \n      for (const formPage of formPages) {\n        await page.goto(formPage);\n        \n        for (const test of autocompleteTests) {\n          let selector = '';\n          \n          if (test.type) {\n            selector = `input[type=\"${test.type}\"]`;\n          } else if (test.name) {\n            selector = `input[name*=\"${test.name}\"], input[id*=\"${test.name}\"]`;\n          }\n          \n          const fields = await page.locator(selector).all();\n          \n          for (const field of fields) {\n            const autocomplete = await field.getAttribute('autocomplete');\n            const fieldName = await field.getAttribute('name');\n            const fieldId = await field.getAttribute('id');\n            \n            if (autocomplete) {\n              expect(\n                autocomplete,\n                `Field ${fieldName || fieldId} should have autocomplete=\"${test.expected}\"`\n              ).toBe(test.expected);\n            } else {\n              console.warn(\n                `Field ${fieldName || fieldId} on ${formPage} could benefit from autocomplete=\"${test.expected}\"`\n              );\n            }\n          }\n        }\n      }\n    });\n\n    test('should have appropriate input types and modes', async ({ page }) => {\n      const formPages = ['/register', '/profile'];\n      \n      const inputTypeTests = [\n        { purpose: 'email', expectedType: 'email', expectedMode: 'email' },\n        { purpose: 'phone', expectedType: 'tel', expectedMode: 'tel' },\n        { purpose: 'url', expectedType: 'url', expectedMode: 'url' },\n        { purpose: 'number', expectedType: 'number', expectedMode: 'numeric' },\n        { purpose: 'search', expectedType: 'search', expectedMode: null }\n      ];\n      \n      for (const formPage of formPages) {\n        await page.goto(formPage);\n        \n        for (const test of inputTypeTests) {\n          const fields = await page.locator(`input[name*=\"${test.purpose}\"], input[id*=\"${test.purpose}\"], input[placeholder*=\"${test.purpose}\"]`).all();\n          \n          for (const field of fields) {\n            const inputType = await field.getAttribute('type');\n            const inputMode = await field.getAttribute('inputmode');\n            const fieldName = await field.getAttribute('name');\n            \n            if (inputType && inputType !== test.expectedType) {\n              console.warn(\n                `Field ${fieldName} for ${test.purpose} should use type=\"${test.expectedType}\" instead of \"${inputType}\"`\n              );\n            }\n            \n            if (test.expectedMode && inputMode !== test.expectedMode) {\n              console.warn(\n                `Field ${fieldName} for ${test.purpose} should use inputmode=\"${test.expectedMode}\"`\n              );\n            }\n          }\n        }\n      }\n    });\n  });\n\n  test.describe('Form Instructions and Help', () => {\n    test('should provide clear instructions for form completion', async ({ page }) => {\n      const formPages = ['/register', '/profile'];\n      \n      for (const formPage of formPages) {\n        await page.goto(formPage);\n        \n        // Look for form instructions\n        const instructions = await page.locator(\n          '.form-instructions, .form-help, [role=\"group\"] p, form > p, [aria-describedby]'\n        ).all();\n        \n        for (const instruction of instructions) {\n          const instructionText = await instruction.textContent();\n          \n          expect(\n            instructionText?.trim().length,\n            'Form instructions should have meaningful content'\n          ).toBeGreaterThan(0);\n        }\n        \n        // Check for password requirements if password field exists\n        const passwordFields = await page.locator('input[type=\"password\"]').all();\n        \n        if (passwordFields.length > 0) {\n          const passwordRequirements = await page.locator(\n            'text=\"password must\", text=\"password should\", text=\"minimum\", [id*=\"password-help\"], [id*=\"password-requirements\"]'\n          ).count();\n          \n          expect(\n            passwordRequirements,\n            `Page ${formPage} should provide password requirements`\n          ).toBeGreaterThan(0);\n        }\n      }\n    });\n\n    test('should provide help text for complex fields', async ({ page }) => {\n      await page.goto('/profile');\n      \n      const complexFields = await page.locator(\n        'input[type=\"password\"], input[pattern], input[type=\"tel\"], input[type=\"date\"], select[multiple]'\n      ).all();\n      \n      for (const field of complexFields) {\n        const fieldType = await field.getAttribute('type');\n        const fieldName = await field.getAttribute('name');\n        const describedBy = await field.getAttribute('aria-describedby');\n        \n        if (describedBy) {\n          const helpTextIds = describedBy.split(' ');\n          \n          for (const helpId of helpTextIds) {\n            const helpElement = await page.locator(`#${helpId}`).first();\n            \n            if (await helpElement.count() > 0) {\n              const helpText = await helpElement.textContent();\n              \n              expect(\n                helpText?.trim().length,\n                `Help text for ${fieldType} field should be meaningful`\n              ).toBeGreaterThan(0);\n            }\n          }\n        } else if (fieldType === 'password' || fieldType === 'tel') {\n          console.warn(\n            `Complex field ${fieldName} (${fieldType}) should have associated help text`\n          );\n        }\n      }\n    });\n\n    test('should support contextual help', async ({ page }) => {\n      await page.goto('/profile');\n      \n      // Look for help buttons or info icons\n      const helpTriggers = await page.locator(\n        'button[aria-label*=\"help\"], [data-tooltip], [title], .help-icon, .info-icon'\n      ).all();\n      \n      for (const trigger of helpTriggers.slice(0, 3)) {\n        const hasAccessibleName = await accessibilityHelper.hasAccessibleName(trigger);\n        expect(\n          hasAccessibleName,\n          'Help triggers should have accessible names'\n        ).toBeTruthy();\n        \n        // Test activation\n        await trigger.click();\n        await page.waitForTimeout(500);\n        \n        // Look for help content\n        const helpContent = await page.locator(\n          '[role=\"tooltip\"], .tooltip, .help-text:visible, [aria-expanded=\"true\"] + .help-content'\n        ).first();\n        \n        if (await helpContent.count() > 0) {\n          const contentText = await helpContent.textContent();\n          \n          expect(\n            contentText?.trim().length,\n            'Help content should be meaningful'\n          ).toBeGreaterThan(0);\n          \n          // Help content should be keyboard accessible\n          const isKeyboardAccessible = await accessibilityPage.isKeyboardAccessible(helpContent);\n          \n          if (!isKeyboardAccessible) {\n            // Content should at least be announced by screen readers\n            const role = await helpContent.getAttribute('role');\n            const ariaLive = await helpContent.getAttribute('aria-live');\n            \n            const isAnnounced = role === 'tooltip' ||\n                               ariaLive === 'polite' ||\n                               ariaLive === 'assertive';\n            \n            expect(\n              isAnnounced,\n              'Help content should be announced to screen readers'\n            ).toBeTruthy();\n          }\n        }\n      }\n    });\n  });\n\n  test.describe('Form Submission and Feedback', () => {\n    test('should provide accessible form submission feedback', async ({ page }) => {\n      await page.goto('/login');\n      \n      // Fill out form correctly\n      const emailField = await page.locator('input[type=\"email\"]').first();\n      const passwordField = await page.locator('input[type=\"password\"]').first();\n      \n      if (await emailField.count() > 0 && await passwordField.count() > 0) {\n        await emailField.fill('user@example.com');\n        await passwordField.fill('password123');\n        \n        // Submit form\n        const submitButton = await page.locator('button[type=\"submit\"]').first();\n        await submitButton.click();\n        await page.waitForTimeout(2000);\n        \n        // Look for feedback (success or error)\n        const feedbackElements = await page.locator(\n          '[role=\"alert\"], [role=\"status\"], [aria-live=\"polite\"], [aria-live=\"assertive\"], .success, .error, .message'\n        ).all();\n        \n        for (const feedback of feedbackElements) {\n          const isVisible = await feedback.isVisible();\n          \n          if (isVisible) {\n            const feedbackText = await feedback.textContent();\n            \n            expect(\n              feedbackText?.trim().length,\n              'Form submission feedback should have meaningful content'\n            ).toBeGreaterThan(0);\n            \n            // Should be announced to screen readers\n            const role = await feedback.getAttribute('role');\n            const ariaLive = await feedback.getAttribute('aria-live');\n            \n            const isAnnounced = role === 'alert' ||\n                               role === 'status' ||\n                               ariaLive === 'polite' ||\n                               ariaLive === 'assertive';\n            \n            expect(\n              isAnnounced,\n              'Form feedback should be announced to screen readers'\n            ).toBeTruthy();\n          }\n        }\n      }\n    });\n\n    test('should handle form submission loading states accessibly', async ({ page }) => {\n      await page.goto('/register');\n      \n      const submitButton = await page.locator('button[type=\"submit\"]').first();\n      \n      if (await submitButton.count() > 0) {\n        // Check initial state\n        const initialText = await accessibilityHelper.getAccessibleName(submitButton);\n        const initialDisabled = await submitButton.isDisabled();\n        \n        // Click submit (even if form is invalid to test loading state)\n        await submitButton.click();\n        await page.waitForTimeout(500);\n        \n        // Button should indicate loading state\n        const loadingText = await accessibilityHelper.getAccessibleName(submitButton);\n        const isDisabledDuringSubmit = await submitButton.isDisabled();\n        const hasAriaBusy = await submitButton.getAttribute('aria-busy');\n        \n        const hasLoadingIndication = loadingText !== initialText ||\n                                    hasAriaBusy === 'true' ||\n                                    isDisabledDuringSubmit !== initialDisabled;\n        \n        if (hasLoadingIndication) {\n          expect(\n            loadingText.length,\n            'Loading state should have accessible name'\n          ).toBeGreaterThan(0);\n          \n          console.log(`Submit button loading state: \"${loadingText}\"`);\n        }\n      }\n    });\n\n    test('should prevent duplicate form submissions accessibly', async ({ page }) => {\n      await page.goto('/register');\n      \n      const submitButton = await page.locator('button[type=\"submit\"]').first();\n      \n      if (await submitButton.count() > 0) {\n        // Fill required fields to allow submission\n        const requiredFields = await accessibilityPage.getRequiredFields();\n        \n        for (const field of requiredFields.slice(0, 3)) {\n          const fieldType = await field.getAttribute('type');\n          \n          if (fieldType === 'email') {\n            await field.fill('test@example.com');\n          } else if (fieldType === 'password') {\n            await field.fill('password123');\n          } else {\n            await field.fill('test value');\n          }\n        }\n        \n        // First submission\n        await submitButton.click();\n        await page.waitForTimeout(200);\n        \n        // Button should be disabled or show loading state\n        const isDisabled = await submitButton.isDisabled();\n        const ariaBusy = await submitButton.getAttribute('aria-busy');\n        const buttonText = await accessibilityHelper.getAccessibleName(submitButton);\n        \n        const hasProtection = isDisabled ||\n                             ariaBusy === 'true' ||\n                             buttonText.toLowerCase().includes('submitting') ||\n                             buttonText.toLowerCase().includes('loading');\n        \n        expect(\n          hasProtection,\n          'Form should prevent duplicate submissions accessibly'\n        ).toBeTruthy();\n      }\n    });\n  });\n\n  test.describe('Mobile Form Accessibility', () => {\n    test('should be accessible on mobile devices', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      await page.goto('/login');\n      \n      // Form should be usable at mobile viewport\n      const results = await new AxeBuilder({ page })\n        .withTags(['wcag2a', 'wcag2aa'])\n        .analyze();\n        \n      expect(results.violations, 'Forms should be accessible on mobile').toEqual([]);\n      \n      // Touch targets should be adequate\n      const interactiveElements = await accessibilityPage.getInteractiveElements();\n      \n      for (const element of interactiveElements.slice(0, 5)) {\n        const boundingBox = await element.boundingBox();\n        \n        if (boundingBox) {\n          expect(\n            Math.min(boundingBox.width, boundingBox.height),\n            'Touch targets should be at least 44px'\n          ).toBeGreaterThanOrEqual(44);\n        }\n      }\n      \n      // Input types should trigger appropriate mobile keyboards\n      const emailInputs = await page.locator('input[type=\"email\"]').all();\n      \n      for (const input of emailInputs) {\n        const inputMode = await input.getAttribute('inputmode');\n        const type = await input.getAttribute('type');\n        \n        expect(\n          type === 'email' || inputMode === 'email',\n          'Email inputs should trigger email keyboard on mobile'\n        ).toBeTruthy();\n      }\n    });\n\n    test('should handle virtual keyboard properly', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      await page.goto('/register');\n      \n      const inputs = await page.locator('input, textarea').all();\n      \n      for (const input of inputs.slice(0, 3)) {\n        await input.focus();\n        await page.waitForTimeout(300);\n        \n        // Input should still be visible when virtual keyboard is open\n        const inputBox = await input.boundingBox();\n        \n        if (inputBox) {\n          // On mobile, focused input should be in upper half of screen\n          // to account for virtual keyboard\n          expect(\n            inputBox.y,\n            'Focused input should be visible above virtual keyboard'\n          ).toBeLessThan(300);\n        }\n      }\n    });\n  });\n});