# Service-to-Service Authentication Architecture

## Overview
This document describes the authentication architecture for FocusHive microservices, implementing JWT-based service-to-service authentication with Spring Boot 3 and Spring Security 6.

## Architecture Pattern
We use a **Centralized Authorization Server** pattern where:
- **Identity Service (Port 8081)** acts as the Authorization Server
- All services validate JWT tokens issued by the Identity Service
- Service-to-service communication uses service account JWT tokens

## Service Ports
- **Identity Service**: 8081 (Authorization Server)
- **Music Service**: 8082 (SHELVED - not in use)
- **Notification Service**: 8083
- **Buddy Service**: 8087
- **Backend Service**: 8080

## JWT Token Types

### 1. User JWT Tokens
- Issued when users authenticate via Identity Service
- Contains user ID, roles, and permissions
- Used for user-initiated requests
- Expiration: 1 hour (configurable)

### 2. Service Account JWT Tokens
- Generated by services for service-to-service communication
- Contains service identifier and fixed permissions
- Short-lived (5 minutes default)
- Auto-refreshed when near expiration

## Implementation Components

### Identity Service (Authorization Server)

#### JWT Endpoints
```yaml
# Token validation endpoint
GET /api/v1/auth/validate
Authorization: Bearer {token}

# JWKS endpoint for public key
GET /.well-known/jwks.json

# OpenID Discovery
GET /.well-known/openid-configuration
```

#### Service Token Generation
```java
// ServiceJwtTokenProvider.java
public String generateServiceToken() {
    Map<String, Object> claims = new HashMap<>();
    claims.put("service", serviceName);
    claims.put("type", "service-account");
    claims.put("roles", Arrays.asList("SERVICE"));
    claims.put("permissions", getServicePermissions());

    return jwtTokenProvider.generateToken(subject, claims, expirationSeconds);
}
```

### Client Services Configuration

#### Application Properties
```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://identity-service:8081
          jwk-set-uri: http://identity-service:8081/.well-known/jwks.json
```

#### Feign Client Configuration
```java
@Bean
public RequestInterceptor serviceAuthInterceptor() {
    return requestTemplate -> {
        // Get or generate service token
        String serviceToken = serviceJwtTokenProvider.generateServiceToken();
        requestTemplate.header("Authorization", "Bearer " + serviceToken);
        requestTemplate.header("X-Service-Name", serviceName);
        requestTemplate.header("X-Correlation-ID", UUID.randomUUID().toString());
    };
}
```

## Service Authentication Flow

### User-Initiated Request Flow
1. User → Backend Service (with user JWT)
2. Backend validates JWT with Identity Service
3. Backend → Other Service (forwards user JWT + adds service headers)
4. Other Service validates JWT
5. Response flows back

### Service-to-Service Flow
1. Service A generates service account JWT
2. Service A → Service B (with service JWT)
3. Service B validates JWT with Identity Service
4. Service B processes request
5. Response flows back

## Security Headers

All service requests must include:
- `Authorization: Bearer {jwt_token}`
- `X-Service-Name: {calling_service_name}`
- `X-Correlation-ID: {uuid}` (for distributed tracing)
- `X-Request-Timestamp: {epoch_millis}` (optional, for debugging)

## Docker Environment Configuration

### Identity Service
```yaml
environment:
  JWT_SECRET: ${JWT_SECRET}
  JWT_ISSUER: http://identity-service:8081
  SERVICE_AUTH_ENABLED: true
```

### Client Services
```yaml
environment:
  JWT_ISSUER_URI: http://identity-service:8081
  JWT_JWK_SET_URI: http://identity-service:8081/.well-known/jwks.json
  IDENTITY_SERVICE_URL: http://identity-service:8081
```

## Error Handling

### Authentication Errors
- **401 Unauthorized**: Invalid or missing JWT token
- **403 Forbidden**: Valid token but insufficient permissions
- **498 Token Expired**: JWT token has expired

### Retry Strategy
- Service tokens are cached for 4 minutes (5-minute validity)
- Auto-refresh when <1 minute remaining
- Circuit breaker pattern for Identity Service calls
- Fallback to cached user profiles when Identity Service unavailable

## Testing Authentication

### Generate Service Token (curl)
```bash
# Get service token from Identity Service
curl -X POST http://localhost:8081/api/v1/auth/service-token \
  -H "X-Service-Name: test-service" \
  -H "X-API-Key: ${SERVICE_API_KEY}"
```

### Validate Token
```bash
# Validate any JWT token
curl -X GET http://localhost:8081/api/v1/auth/validate \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

### Test Service-to-Service Call
```bash
# Backend calling Notification Service
curl -X POST http://localhost:8083/api/v1/notifications/send \
  -H "Authorization: Bearer ${SERVICE_JWT}" \
  -H "X-Service-Name: focushive-backend" \
  -H "Content-Type: application/json" \
  -d '{"userId": "123", "message": "Test notification"}'
```

## Common Issues & Solutions

### Issue 1: 401 Unauthorized between services
**Cause**: Wrong JWT issuer URI or expired token
**Solution**: Ensure all services point to `http://identity-service:8081`

### Issue 2: Connection refused
**Cause**: Services using localhost instead of service names in Docker
**Solution**: Use Docker service names (identity-service, not localhost)

### Issue 3: Token validation fails
**Cause**: JWT secret mismatch or wrong signing algorithm
**Solution**: Ensure all services use same JWT_SECRET environment variable

### Issue 4: JWKS endpoint not accessible
**Cause**: Identity Service not exposing JWKS endpoint
**Solution**: Implement `/.well-known/jwks.json` endpoint in Identity Service

## Production Considerations

1. **Use HTTPS**: Always use TLS in production
2. **Rotate Secrets**: Implement JWT secret rotation mechanism
3. **Short Token Expiry**: Keep service tokens short-lived (5-15 minutes)
4. **Rate Limiting**: Implement rate limiting on token validation endpoints
5. **Monitoring**: Track authentication failures and latency
6. **Caching**: Cache JWKS and validated tokens appropriately
7. **Zero-Trust**: Validate tokens on every request, don't trust network boundaries

## Migration Steps

To implement this authentication architecture:

1. **Update Identity Service**:
   - Add JWKS endpoint
   - Add service token generation endpoint
   - Configure JWT signing with RSA keys

2. **Update Client Services**:
   - Fix JWT issuer URI to port 8081
   - Add Feign interceptors for service tokens
   - Configure Spring Security resource server

3. **Update Docker Compose**:
   - Add JWT configuration environment variables
   - Ensure services use Docker network names
   - Configure health checks for readiness

4. **Test All Service Pairs**:
   - Identity → Notification
   - Backend → Notification
   - Backend → Buddy
   - Identity → Backend

## Monitoring & Observability

### Metrics to Track
- Token generation rate
- Token validation success/failure rate
- Service-to-service call latency
- Authentication errors by service
- Token expiry events

### Log Correlation
All services should log:
- Correlation ID from X-Correlation-ID header
- Service name from X-Service-Name header
- User ID from JWT claims (if present)
- Authentication result (success/failure)

## References
- [Spring Security OAuth2 Resource Server](https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html)
- [Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/index.html)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)