package com.focushive.buddy.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * Entity representing user preferences for buddy matching.
 * Contains all user-specific preferences used by the matching algorithm
 * to find compatible accountability partners.
 *
 * Database mapping:
 * - Maps to buddy_preferences table
 * - Uses PostgreSQL-specific features: JSONB for preferred_work_hours, TEXT[] for focus_areas/goals
 * - Includes audit fields (created_at, updated_at)
 */
@Entity
@Table(name = "buddy_preferences")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BuddyPreferences {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @NotNull
    @Column(name = "user_id", nullable = false, unique = true)
    private UUID userId;

    @Size(max = 50)
    @Column(name = "preferred_timezone", length = 50)
    private String preferredTimezone;

    /**
     * PostgreSQL JSONB field storing work hours as a map.
     * Format: {"monday": {"startHour": 9, "endHour": 17}, ...}
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "preferred_work_hours", columnDefinition = "jsonb")
    @Builder.Default
    private Map<String, Object> preferredWorkHours = Map.of();

    /**
     * PostgreSQL TEXT[] array storing focus areas.
     * Examples: ["CODING", "STUDYING", "RESEARCH", "WRITING"]
     */
    @JdbcTypeCode(SqlTypes.ARRAY)
    @Column(name = "focus_areas", columnDefinition = "text[]")
    private String[] focusAreas;

    /**
     * PostgreSQL TEXT[] array storing user goals.
     * Examples: ["complete_project", "learn_new_skills", "improve_focus"]
     */
    @JdbcTypeCode(SqlTypes.ARRAY)
    @Column(name = "goals", columnDefinition = "text[]")
    private String[] goals;

    @Size(max = 50)
    @Column(name = "communication_style", length = 50)
    private String communicationStyle;

    @Builder.Default
    @Column(name = "matching_enabled", nullable = false)
    private Boolean matchingEnabled = true;

    @Min(0)
    @Max(12)
    @Builder.Default
    @Column(name = "timezone_flexibility")
    private Integer timezoneFlexibility = 2;

    @Min(1)
    @Max(168) // Max hours in a week
    @Builder.Default
    @Column(name = "min_commitment_hours")
    private Integer minCommitmentHours = 10;

    @Min(1)
    @Max(10)
    @Builder.Default
    @Column(name = "max_partners")
    private Integer maxPartners = 3;

    @Size(min = 2, max = 10)
    @Pattern(regexp = "^[a-z]{2,3}(-[A-Z]{2})?$", message = "Language must be in ISO format (e.g., 'en', 'es', 'en-US')")
    @Builder.Default
    @Column(name = "language", length = 10)
    private String language = "en";

    @Size(max = 50)
    @Column(name = "personality_type", length = 20)
    private String personalityType;

    @Size(max = 20)
    @Column(name = "experience_level", length = 20)
    private String experienceLevel;

    @Column(name = "last_active_at")
    private LocalDateTime lastActiveAt;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // Getters and Setters are automatically generated by @Data annotation
    // Only adding custom method for backward compatibility

    public Boolean isMatchingEnabled() {
        return matchingEnabled;
    }

    // Utility methods for working with arrays and JSONB

    /**
     * Checks if user has a specific focus area.
     */
    public boolean hasFocusArea(String focusArea) {
        if (focusAreas == null) {
            return false;
        }
        for (String area : focusAreas) {
            if (area != null && area.equalsIgnoreCase(focusArea)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if user has a specific goal.
     */
    public boolean hasGoal(String goal) {
        if (goals == null) {
            return false;
        }
        for (String userGoal : goals) {
            if (userGoal != null && userGoal.equalsIgnoreCase(goal)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Gets work start hour for a specific day.
     */
    public Integer getWorkStartHour(String dayOfWeek) {
        if (preferredWorkHours == null) {
            return null;
        }

        @SuppressWarnings("unchecked")
        Map<String, Object> dayHours = (Map<String, Object>) preferredWorkHours.get(dayOfWeek.toLowerCase());

        if (dayHours == null) {
            return null;
        }

        Object startHour = dayHours.get("startHour");
        return startHour instanceof Number ? ((Number) startHour).intValue() : null;
    }

    /**
     * Gets work end hour for a specific day.
     */
    public Integer getWorkEndHour(String dayOfWeek) {
        if (preferredWorkHours == null) {
            return null;
        }

        @SuppressWarnings("unchecked")
        Map<String, Object> dayHours = (Map<String, Object>) preferredWorkHours.get(dayOfWeek.toLowerCase());

        if (dayHours == null) {
            return null;
        }

        Object endHour = dayHours.get("endHour");
        return endHour instanceof Number ? ((Number) endHour).intValue() : null;
    }

    /**
     * Checks if this user is currently active based on last_active_at.
     */
    public boolean isRecentlyActive(int maxInactiveDays) {
        if (lastActiveAt == null) {
            return false; // Never been active
        }
        return lastActiveAt.isAfter(LocalDateTime.now().minusDays(maxInactiveDays));
    }

    /**
     * Updates the last active timestamp to now.
     */
    public void updateLastActiveNow() {
        this.lastActiveAt = LocalDateTime.now();
    }
}