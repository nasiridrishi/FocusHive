package com.focushive.buddy.entity;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.focushive.user.entity.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.test.context.TestPropertySource;

import java.util.Arrays;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH", 
    "spring.jpa.hibernate.ddl-auto=create-drop",
    "spring.flyway.enabled=false"
})
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@EnableJpaAuditing
class BuddyPreferencesTest {

    @Autowired
    private TestEntityManager entityManager;

    private User testUser;

    @BeforeEach
    void setUp() {
        // Create a test user with all required fields
        testUser = new User();
        // Don't set ID manually - let it be generated by UUID strategy
        testUser.setEmail("test@example.com");
        testUser.setUsername("testuser");
        testUser.setDisplayName("Test User");
        testUser.setPassword("testpassword123");
        // Set timezone and locale with proper formats to satisfy validation
        testUser.setTimezone("UTC");
        testUser.setLocale("en-US");
        // Set default UserRole if not set by constructor
        testUser.setRole(User.UserRole.USER);
        
        entityManager.persistAndFlush(testUser);
        entityManager.clear();
    }

    @Test
    void shouldPersistAndRetrieveBuddyPreferencesWithWorkHours() {
        // Given
        Map<String, BuddyPreferences.WorkHours> workHours = Map.of(
                "MONDAY", new BuddyPreferences.WorkHours(9, 17),
                "TUESDAY", new BuddyPreferences.WorkHours(10, 18),
                "WEDNESDAY", new BuddyPreferences.WorkHours(9, 16)
        );

        BuddyPreferences preferences = BuddyPreferences.builder()
                .user(testUser)
                .preferredTimezone("America/New_York")
                .preferredWorkHours(workHours)
                .focusAreas(new String[]{"coding", "reading", "writing"})
                .communicationStyle(BuddyPreferences.CommunicationStyle.MODERATE)
                .matchingEnabled(true)
                .build();

        // When
        BuddyPreferences savedPreferences = entityManager.persistAndFlush(preferences);
        entityManager.clear();

        // Then
        BuddyPreferences retrievedPreferences = entityManager.find(BuddyPreferences.class, savedPreferences.getId());
        
        assertThat(retrievedPreferences).isNotNull();
        assertThat(retrievedPreferences.getUser().getId()).isEqualTo(testUser.getId());
        assertThat(retrievedPreferences.getPreferredTimezone()).isEqualTo("America/New_York");
        
        // Verify work hours are correctly persisted and retrieved
        Map<String, BuddyPreferences.WorkHours> retrievedWorkHours = retrievedPreferences.getPreferredWorkHours();
        assertThat(retrievedWorkHours).hasSize(3);
        assertThat(retrievedWorkHours.get("MONDAY")).isEqualTo(new BuddyPreferences.WorkHours(9, 17));
        assertThat(retrievedWorkHours.get("TUESDAY")).isEqualTo(new BuddyPreferences.WorkHours(10, 18));
        assertThat(retrievedWorkHours.get("WEDNESDAY")).isEqualTo(new BuddyPreferences.WorkHours(9, 16));
        
        assertThat(retrievedPreferences.getFocusAreas()).containsExactlyInAnyOrder("coding", "reading", "writing");
        assertThat(retrievedPreferences.getCommunicationStyle()).isEqualTo(BuddyPreferences.CommunicationStyle.MODERATE);
        assertThat(retrievedPreferences.getMatchingEnabled()).isTrue();
    }

    @Test
    void shouldHandleEmptyWorkHours() {
        // Given
        BuddyPreferences preferences = BuddyPreferences.builder()
                .user(testUser)
                .preferredTimezone("UTC")
                .preferredWorkHours(Map.of())
                .focusAreas(new String[]{"studying"})
                .communicationStyle(BuddyPreferences.CommunicationStyle.MINIMAL)
                .matchingEnabled(false)
                .build();

        // When
        BuddyPreferences savedPreferences = entityManager.persistAndFlush(preferences);
        entityManager.clear();

        // Then
        BuddyPreferences retrievedPreferences = entityManager.find(BuddyPreferences.class, savedPreferences.getId());
        
        assertThat(retrievedPreferences.getPreferredWorkHours()).isEmpty();
        assertThat(retrievedPreferences.getMatchingEnabled()).isFalse();
    }

    @Test
    void shouldHandleNullWorkHours() {
        // Given
        BuddyPreferences preferences = BuddyPreferences.builder()
                .user(testUser)
                .preferredTimezone("Europe/London")
                .preferredWorkHours(null)
                .focusAreas(new String[]{"research"})
                .communicationStyle(BuddyPreferences.CommunicationStyle.FREQUENT)
                .matchingEnabled(true)
                .build();

        // When
        BuddyPreferences savedPreferences = entityManager.persistAndFlush(preferences);
        entityManager.clear();

        // Then
        BuddyPreferences retrievedPreferences = entityManager.find(BuddyPreferences.class, savedPreferences.getId());
        
        assertThat(retrievedPreferences.getPreferredWorkHours()).isNull();
    }

    @Test
    void workHoursOverlapShouldWorkCorrectly() {
        // Given
        BuddyPreferences.WorkHours morning = new BuddyPreferences.WorkHours(8, 12);
        BuddyPreferences.WorkHours afternoon = new BuddyPreferences.WorkHours(13, 17);
        BuddyPreferences.WorkHours overlap = new BuddyPreferences.WorkHours(10, 15);

        // When & Then
        assertThat(morning.overlaps(afternoon)).isFalse();
        assertThat(morning.overlaps(overlap)).isTrue();
        assertThat(afternoon.overlaps(overlap)).isTrue();
        
        assertThat(morning.overlapHours(afternoon)).isEqualTo(0);
        assertThat(morning.overlapHours(overlap)).isEqualTo(2); // 10-12
        assertThat(afternoon.overlapHours(overlap)).isEqualTo(2); // 13-15
    }

    @Test
    void focusAreaOverlapShouldWorkCorrectly() {
        // Given
        BuddyPreferences preferences = BuddyPreferences.builder()
                .user(testUser)
                .focusAreas(new String[]{"coding", "reading", "writing"})
                .build();

        // When & Then
        assertThat(preferences.hasFocusAreaOverlap(new String[]{"coding", "music"})).isTrue();
        assertThat(preferences.hasFocusAreaOverlap(new String[]{"music", "gaming"})).isFalse();
        assertThat(preferences.countFocusAreaOverlap(new String[]{"coding", "reading", "music"})).isEqualTo(2);
    }

    @Test
    void shouldSerializeWorkHoursToJsonCorrectly() throws JsonProcessingException {
        // Given
        BuddyPreferences.WorkHours workHours = new BuddyPreferences.WorkHours(9, 17);
        ObjectMapper objectMapper = new ObjectMapper();

        // When
        String json = objectMapper.writeValueAsString(workHours);
        BuddyPreferences.WorkHours deserialized = objectMapper.readValue(json, BuddyPreferences.WorkHours.class);

        // Then
        assertThat(deserialized).isEqualTo(workHours);
        assertThat(json).contains("\"startHour\":9");
        assertThat(json).contains("\"endHour\":17");
    }
}