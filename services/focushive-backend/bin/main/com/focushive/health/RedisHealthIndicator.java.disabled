package com.focushive.health;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuator.health.Health;
import org.springframework.boot.actuator.health.HealthIndicator;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * Custom Redis health indicator that provides detailed health information
 * including connection status, performance metrics, and configuration details.
 */
@Component("redisHealthIndicator")
public class RedisHealthIndicator implements HealthIndicator {

    private static final Logger logger = LoggerFactory.getLogger(RedisHealthIndicator.class);

    @Autowired
    private RedisConnectionFactory redisConnectionFactory;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Value("${focushive.redis.health.timeout:5s}")
    private Duration healthCheckTimeout;

    @Value("${focushive.redis.health.failure-threshold:3}")
    private int failureThreshold;

    @Value("${focushive.redis.health.check-interval:30s}")
    private Duration checkInterval;

    // Track health check history for more intelligent reporting
    private volatile int consecutiveFailures = 0;
    private volatile Instant lastSuccessfulCheck = Instant.now();
    private volatile Instant lastFailedCheck = null;
    private volatile String lastErrorMessage = null;

    @Override
    public Health health() {
        try {
            return performHealthCheck();
        } catch (Exception e) {
            consecutiveFailures++;
            lastFailedCheck = Instant.now();
            lastErrorMessage = e.getMessage();
            
            logger.error("Redis health check failed (consecutive failures: {}): {}", 
                consecutiveFailures, e.getMessage());
            
            return Health.down()
                .withDetail("error", e.getMessage())
                .withDetail("consecutiveFailures", consecutiveFailures)
                .withDetail("lastFailedCheck", lastFailedCheck)
                .withDetail("failureThreshold", failureThreshold)
                .build();
        }
    }

    /**
     * Performs comprehensive Redis health check.
     */
    private Health performHealthCheck() {
        Instant checkStart = Instant.now();
        
        try (RedisConnection connection = redisConnectionFactory.getConnection()) {
            // Test 1: Basic connectivity with ping
            String pingResult = connection.ping();
            if (!"PONG".equals(pingResult)) {
                throw new RuntimeException("Redis ping failed, got: " + pingResult);
            }

            // Test 2: Test read/write operations
            testReadWriteOperations(connection);

            // Test 3: Get Redis server info
            Properties serverInfo = connection.info();

            // Test 4: Check memory usage and performance
            Map<String, Object> performanceMetrics = collectPerformanceMetrics(connection, serverInfo);

            Duration checkDuration = Duration.between(checkStart, Instant.now());

            // Reset failure count on successful check
            consecutiveFailures = 0;
            lastSuccessfulCheck = Instant.now();
            lastErrorMessage = null;

            // Build detailed health response
            Health.Builder healthBuilder = Health.up()
                .withDetail("ping", "PONG")
                .withDetail("checkDuration", checkDuration.toMillis() + "ms")
                .withDetail("lastSuccessfulCheck", lastSuccessfulCheck)
                .withDetail("consecutiveFailures", 0);

            // Add server information
            addServerDetails(healthBuilder, serverInfo);

            // Add performance metrics
            healthBuilder.withDetails(performanceMetrics);

            // Add connection pool information
            addConnectionPoolDetails(healthBuilder);

            return healthBuilder.build();

        } catch (Exception e) {
            consecutiveFailures++;
            lastFailedCheck = Instant.now();
            lastErrorMessage = e.getMessage();
            
            throw e; // Re-throw to be handled by caller
        }
    }

    /**
     * Tests basic read/write operations to ensure Redis is fully functional.
     */
    private void testReadWriteOperations(RedisConnection connection) {
        try {
            String testKey = "health:check:" + System.currentTimeMillis();
            String testValue = "health-check-value";
            byte[] keyBytes = testKey.getBytes();
            byte[] valueBytes = testValue.getBytes();

            // Test SET operation
            Boolean setResult = connection.set(keyBytes, valueBytes);
            if (!Boolean.TRUE.equals(setResult)) {
                throw new RuntimeException("Redis SET operation failed");
            }

            // Test GET operation
            byte[] retrievedValue = connection.get(keyBytes);
            if (retrievedValue == null || !testValue.equals(new String(retrievedValue))) {
                throw new RuntimeException("Redis GET operation failed - value mismatch");
            }

            // Test DELETE operation
            Long deleteResult = connection.del(keyBytes);
            if (!Long.valueOf(1).equals(deleteResult)) {
                throw new RuntimeException("Redis DELETE operation failed");
            }

        } catch (Exception e) {
            throw new RuntimeException("Redis read/write operations failed: " + e.getMessage(), e);
        }
    }

    /**
     * Collects performance and operational metrics from Redis.
     */
    private Map<String, Object> collectPerformanceMetrics(RedisConnection connection, Properties serverInfo) {
        Map<String, Object> metrics = new HashMap<>();

        try {
            // Memory metrics
            String usedMemory = serverInfo.getProperty("used_memory_human");
            String maxMemory = serverInfo.getProperty("maxmemory_human");
            String memoryUsageRatio = serverInfo.getProperty("used_memory_rss_human");
            
            if (usedMemory != null) metrics.put("memoryUsed", usedMemory);
            if (maxMemory != null && !maxMemory.equals("0B")) metrics.put("memoryMax", maxMemory);
            if (memoryUsageRatio != null) metrics.put("memoryRss", memoryUsageRatio);

            // Connection metrics
            String connectedClients = serverInfo.getProperty("connected_clients");
            String maxClients = serverInfo.getProperty("maxclients");
            
            if (connectedClients != null) metrics.put("connectedClients", Integer.parseInt(connectedClients));
            if (maxClients != null) metrics.put("maxClients", Integer.parseInt(maxClients));

            // Performance metrics
            String totalCommandsProcessed = serverInfo.getProperty("total_commands_processed");
            String instantaneousOpsPerSec = serverInfo.getProperty("instantaneous_ops_per_sec");
            
            if (totalCommandsProcessed != null) {
                metrics.put("totalCommandsProcessed", Long.parseLong(totalCommandsProcessed));
            }
            if (instantaneousOpsPerSec != null) {
                metrics.put("operationsPerSecond", Integer.parseInt(instantaneousOpsPerSec));
            }

            // Keyspace metrics
            addKeyspaceMetrics(metrics, serverInfo);

            // Persistence metrics
            addPersistenceMetrics(metrics, serverInfo);

            // Replication metrics (if applicable)
            addReplicationMetrics(metrics, serverInfo);

        } catch (NumberFormatException e) {
            logger.warn("Error parsing Redis metrics: {}", e.getMessage());
            metrics.put("metricsParsingError", e.getMessage());
        }

        return metrics;
    }

    /**
     * Adds Redis server details to health response.
     */
    private void addServerDetails(Health.Builder healthBuilder, Properties serverInfo) {
        String redisVersion = serverInfo.getProperty("redis_version");
        String redisMode = serverInfo.getProperty("redis_mode");
        String uptimeInSeconds = serverInfo.getProperty("uptime_in_seconds");
        
        if (redisVersion != null) healthBuilder.withDetail("version", redisVersion);
        if (redisMode != null) healthBuilder.withDetail("mode", redisMode);
        if (uptimeInSeconds != null) {
            long uptime = Long.parseLong(uptimeInSeconds);
            healthBuilder.withDetail("uptime", formatUptime(uptime));
        }
    }

    /**
     * Adds connection pool information to health response.
     */
    private void addConnectionPoolDetails(Health.Builder healthBuilder) {
        Map<String, Object> poolDetails = new HashMap<>();
        
        // Add basic connection factory information
        poolDetails.put("connectionFactoryType", redisConnectionFactory.getClass().getSimpleName());
        
        // If using Lettuce with pooling, add pool metrics
        // Note: Detailed pool metrics would require access to the actual pool configuration
        poolDetails.put("poolingEnabled", "true"); // Assuming pooling is enabled based on our configuration
        
        healthBuilder.withDetail("connectionPool", poolDetails);
    }

    /**
     * Adds keyspace metrics from Redis info.
     */
    private void addKeyspaceMetrics(Map<String, Object> metrics, Properties serverInfo) {
        // Look for keyspace information (db0, db1, etc.)
        Map<String, Object> keyspaceMetrics = new HashMap<>();
        
        for (String key : serverInfo.stringPropertyNames()) {
            if (key.startsWith("db")) {
                String dbInfo = serverInfo.getProperty(key);
                if (dbInfo != null) {
                    // Parse dbInfo like "keys=123,expires=45,avg_ttl=67890"
                    Map<String, String> dbMetrics = parseDbInfo(dbInfo);
                    keyspaceMetrics.put(key, dbMetrics);
                }
            }
        }
        
        if (!keyspaceMetrics.isEmpty()) {
            metrics.put("keyspace", keyspaceMetrics);
        }
    }

    /**
     * Adds persistence-related metrics.
     */
    private void addPersistenceMetrics(Map<String, Object> metrics, Properties serverInfo) {
        Map<String, Object> persistenceMetrics = new HashMap<>();
        
        String rdbChangesSinceLastSave = serverInfo.getProperty("rdb_changes_since_last_save");
        String rdbLastSaveTime = serverInfo.getProperty("rdb_last_save_time");
        String aofEnabled = serverInfo.getProperty("aof_enabled");
        
        if (rdbChangesSinceLastSave != null) {
            persistenceMetrics.put("rdbChangesSinceLastSave", Integer.parseInt(rdbChangesSinceLastSave));
        }
        if (rdbLastSaveTime != null) {
            persistenceMetrics.put("rdbLastSaveTime", Long.parseLong(rdbLastSaveTime));
        }
        if (aofEnabled != null) {
            persistenceMetrics.put("aofEnabled", "1".equals(aofEnabled));
        }
        
        if (!persistenceMetrics.isEmpty()) {
            metrics.put("persistence", persistenceMetrics);
        }
    }

    /**
     * Adds replication-related metrics.
     */
    private void addReplicationMetrics(Map<String, Object> metrics, Properties serverInfo) {
        String role = serverInfo.getProperty("role");
        
        if ("master".equals(role) || "slave".equals(role)) {
            Map<String, Object> replicationMetrics = new HashMap<>();
            replicationMetrics.put("role", role);
            
            if ("master".equals(role)) {
                String connectedSlaves = serverInfo.getProperty("connected_slaves");
                if (connectedSlaves != null) {
                    replicationMetrics.put("connectedSlaves", Integer.parseInt(connectedSlaves));
                }
            }
            
            metrics.put("replication", replicationMetrics);
        }
    }

    /**
     * Parses database info string like "keys=123,expires=45,avg_ttl=67890"
     */
    private Map<String, String> parseDbInfo(String dbInfo) {
        Map<String, String> result = new HashMap<>();
        String[] parts = dbInfo.split(",");
        
        for (String part : parts) {
            String[] keyValue = part.split("=");
            if (keyValue.length == 2) {
                result.put(keyValue[0], keyValue[1]);
            }
        }
        
        return result;
    }

    /**
     * Formats uptime seconds into human-readable format.
     */
    private String formatUptime(long uptimeSeconds) {
        long days = uptimeSeconds / 86400;
        long hours = (uptimeSeconds % 86400) / 3600;
        long minutes = (uptimeSeconds % 3600) / 60;
        
        if (days > 0) {
            return String.format("%dd %dh %dm", days, hours, minutes);
        } else if (hours > 0) {
            return String.format("%dh %dm", hours, minutes);
        } else {
            return String.format("%dm", minutes);
        }
    }

    /**
     * Gets the current failure count (useful for monitoring).
     */
    public int getConsecutiveFailures() {
        return consecutiveFailures;
    }

    /**
     * Gets the last successful check time (useful for monitoring).
     */
    public Instant getLastSuccessfulCheck() {
        return lastSuccessfulCheck;
    }

    /**
     * Gets the last error message (useful for debugging).
     */
    public String getLastErrorMessage() {
        return lastErrorMessage;
    }

    /**
     * Checks if Redis is currently considered healthy based on failure threshold.
     */
    public boolean isHealthy() {
        return consecutiveFailures < failureThreshold;
    }
}