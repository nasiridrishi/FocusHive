package com.focushive.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureWebMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.springSecurity;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Comprehensive OWASP Top 10 vulnerability tests for FocusHive platform.
 * Tests the most critical web application security risks as defined by OWASP.
 * 
 * OWASP Top 10 2021 Coverage:
 * A01:2021 – Broken Access Control ✓
 * A02:2021 – Cryptographic Failures ✓
 * A03:2021 – Injection ✓ 
 * A04:2021 – Insecure Design ✓
 * A05:2021 – Security Misconfiguration ✓
 * A06:2021 – Vulnerable and Outdated Components ✓
 * A07:2021 – Identification and Authentication Failures ✓
 * A08:2021 – Software and Data Integrity Failures ✓
 * A09:2021 – Security Logging and Monitoring Failures ✓
 * A10:2021 – Server-Side Request Forgery (SSRF) ✓
 * 
 * Legacy vulnerabilities also covered:
 * - Cross-Site Scripting (XSS) [now part of A03]
 * - XML External Entities (XXE) [now part of A03]
 * - Cross-Site Request Forgery (CSRF) [now part of A04]
 * 
 * @author FocusHive Security Team
 * @version 2.0
 * @since 2024-12-12
 */
@ExtendWith(SpringExtension.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebMvc
@ActiveProfiles("test")
@DisplayName("OWASP Top 10 Vulnerability Tests")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class OWASPVulnerabilityTest {

    @Autowired
    private WebApplicationContext context;

    @Autowired
    private ObjectMapper objectMapper;

    private MockMvc mockMvc;
    private String validUserToken;
    private String adminToken;

    @BeforeEach
    void setUp() {
        mockMvc = MockMvcBuilders
                .webAppContextSetup(context)
                .apply(springSecurity())
                .build();

        validUserToken = SecurityTestUtils.generateValidJwtToken("testuser");
        adminToken = SecurityTestUtils.generateJwtToken("admin", "ADMIN", 
                Instant.now().plus(1, ChronoUnit.HOURS), UUID.randomUUID());
    }

    // ============== A01:2021 – Broken Access Control ==============

    @Test
    @Order(1)
    @DisplayName("A01: Should prevent broken access control vulnerabilities")
    void testBrokenAccessControl() throws Exception {
        // Test 1: Vertical privilege escalation
        mockMvc.perform(get("/api/v1/admin/users")
                .header("Authorization", "Bearer " + validUserToken))
                .andExpect(status().isForbidden());

        // Test 2: Horizontal privilege escalation
        UUID otherUserId = UUID.randomUUID();
        mockMvc.perform(get("/api/v1/users/" + otherUserId + "/profile")
                .header("Authorization", "Bearer " + validUserToken))
                .andExpected(status().isForbidden());

        // Test 3: IDOR (Insecure Direct Object Reference)
        List<String> idorAttempts = Arrays.asList(
            "/api/v1/personas/1",
            "/api/v1/hives/999999",
            "/api/v1/users/admin",
            "/api/v1/admin/config"
        );

        for (String endpoint : idorAttempts) {
            mockMvc.perform(get(endpoint)
                    .header("Authorization", "Bearer " + validUserToken))
                    .andExpected(result -> 
                        assertTrue(result.getResponse().getStatus() == 403 || 
                                 result.getResponse().getStatus() == 404,
                                 "Should prevent IDOR at " + endpoint));
        }

        // Test 4: Forced browsing
        List<String> restrictedEndpoints = Arrays.asList(
            "/api/v1/admin/",
            "/api/v1/internal/",
            "/actuator/env",
            "/actuator/configprops"
        );

        for (String endpoint : restrictedEndpoints) {
            mockMvc.perform(get(endpoint)
                    .header("Authorization", "Bearer " + validUserToken))
                    .andExpected(result -> 
                        assertTrue(result.getResponse().getStatus() >= 400,
                                 "Should block forced browsing to " + endpoint));
        }
    }

    // ============== A02:2021 – Cryptographic Failures ==============

    @Test
    @Order(2)
    @DisplayName("A02: Should prevent cryptographic failures")
    void testCryptographicFailures() throws Exception {
        // Test 1: Data in transit protection
        // All endpoints should require HTTPS in production (tested via security headers)
        
        // Test 2: Sensitive data in logs/responses
        MvcResult loginResult = mockMvc.perform(post("/api/v1/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"testuser\",\"password\":\"password123\"}"))
                .andReturn();

        String responseBody = loginResult.getResponse().getContentAsString();
        assertFalse(responseBody.contains("password"), 
                   "Passwords should not appear in responses");

        // Test 3: Weak cryptographic algorithms (check JWT implementation)
        String weakToken = SecurityTestUtils.generateValidJwtToken("testuser");
        assertTrue(weakToken.contains("."), "JWT should use proper structure");
        
        // Test 4: Password storage verification
        String testPassword = "TestPassword123!";
        String hashedPassword = SecurityTestUtils.hashPassword(testPassword);
        assertTrue(hashedPassword.startsWith("$2"), 
                  "Passwords should be hashed with strong algorithm (BCrypt)");
    }

    // ============== A03:2021 – Injection ==============

    @Test
    @Order(3)
    @DisplayName("A03: Should prevent injection attacks")
    void testInjectionAttacks() throws Exception {
        // Test 1: SQL Injection
        List<String> sqlPayloads = SecurityTestUtils.getSqlInjectionPayloads();
        
        for (String payload : sqlPayloads) {
            // Test in username field
            Map<String, String> loginRequest = Map.of(
                "username", payload,
                "password", "password"
            );

            mockMvc.perform(post("/api/v1/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(SecurityTestUtils.toJson(loginRequest)))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        String response = result.getResponse().getContentAsString();
                        
                        // Should not return 200 or leak database errors
                        assertTrue(status == 400 || status == 401, 
                                 "SQL injection payload should be rejected");
                        assertFalse(response.toLowerCase().contains("sql"), 
                                   "Should not leak SQL error information");
                        assertFalse(response.toLowerCase().contains("database"), 
                                   "Should not leak database error information");
                    });

            // Test in search endpoints
            mockMvc.perform(get("/api/v1/hives/search?query=" + payload)
                    .header("Authorization", "Bearer " + validUserToken))
                    .andExpected(result -> {
                        String response = result.getResponse().getContentAsString();
                        assertFalse(response.toLowerCase().contains("error"), 
                                   "Should handle malicious search queries gracefully");
                    });
        }

        // Test 2: NoSQL Injection
        List<String> noSqlPayloads = SecurityTestUtils.getNoSqlInjectionPayloads();
        
        for (String payload : noSqlPayloads) {
            mockMvc.perform(post("/api/v1/hives")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(payload))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status >= 400, "NoSQL injection should be rejected");
                    });
        }

        // Test 3: Command Injection
        List<String> commandPayloads = SecurityTestUtils.getCommandInjectionPayloads();
        
        for (String payload : commandPayloads) {
            Map<String, String> profileUpdate = Map.of(
                "firstName", payload,
                "lastName", "Test"
            );

            mockMvc.perform(put("/api/v1/users/profile")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(SecurityTestUtils.toJson(profileUpdate)))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status == 400 || status == 422, 
                                 "Command injection payload should be rejected");
                    });
        }

        // Test 4: LDAP Injection
        String ldapPayload = "admin)(&(password=*))";
        mockMvc.perform(post("/api/v1/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"" + ldapPayload + "\",\"password\":\"test\"}"))
                .andExpected(status().isUnauthorized());
    }

    @Test
    @Order(4)
    @DisplayName("A03: Should prevent XSS attacks")
    void testXSSPrevention() throws Exception {
        List<String> xssPayloads = SecurityTestUtils.getXssPayloads();
        
        for (String payload : xssPayloads) {
            // Test stored XSS in user profile
            Map<String, String> profileData = Map.of(
                "firstName", payload,
                "bio", payload
            );

            MvcResult updateResult = mockMvc.perform(put("/api/v1/users/profile")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(SecurityTestUtils.toJson(profileData)))
                    .andReturn();

            if (updateResult.getResponse().getStatus() < 400) {
                // If update succeeded, check that XSS is properly encoded when retrieved
                MvcResult getResult = mockMvc.perform(get("/api/v1/users/profile")
                        .header("Authorization", "Bearer " + validUserToken))
                        .andExpect(status().isOk())
                        .andReturn();

                String responseBody = getResult.getResponse().getContentAsString();
                
                // Check that dangerous scripts are encoded or removed
                assertFalse(responseBody.contains("<script>"), 
                           "Script tags should be encoded or removed");
                assertFalse(responseBody.contains("javascript:"), 
                           "JavaScript URLs should be encoded or removed");
                assertFalse(responseBody.contains("onerror="), 
                           "Event handlers should be encoded or removed");
            }

            // Test reflected XSS in search
            mockMvc.perform(get("/api/v1/hives/search?query=" + payload)
                    .header("Authorization", "Bearer " + validUserToken))
                    .andExpected(result -> {
                        String response = result.getResponse().getContentAsString();
                        assertFalse(response.contains("<script>"), 
                                   "Reflected XSS should be prevented");
                    });
        }
    }

    @Test
    @Order(5)
    @DisplayName("A03: Should prevent XXE attacks")
    void testXXEPrevention() throws Exception {
        List<String> xxePayloads = SecurityTestUtils.getXxePayloads();
        
        for (String payload : xxePayloads) {
            // Test XXE in XML endpoints (if any)
            mockMvc.perform(post("/api/v1/import/data")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_XML)
                    .content(payload))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        String response = result.getResponse().getContentAsString();
                        
                        // Should reject or safely handle XML
                        if (status < 400) {
                            // If processing succeeded, ensure no sensitive data leaked
                            assertFalse(response.contains("root:"), 
                                       "Should not leak system files via XXE");
                            assertFalse(response.contains("/etc/"), 
                                       "Should not leak system files via XXE");
                        }
                    });
        }
    }

    // ============== A04:2021 – Insecure Design ==============

    @Test
    @Order(6)
    @DisplayName("A04: Should prevent insecure design vulnerabilities")
    void testInsecureDesign() throws Exception {
        // Test 1: CSRF Protection
        String csrfToken = SecurityTestUtils.generateCsrfToken();
        
        // Request without CSRF token should fail for state-changing operations
        mockMvc.perform(post("/api/v1/hives")
                .header("Authorization", "Bearer " + validUserToken)
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"name\":\"Test Hive\"}"))
                .andExpected(result -> {
                    // Should either require CSRF token or use double-submit cookie
                    int status = result.getResponse().getStatus();
                    // For REST APIs, CSRF might not be required if using proper token auth
                    assertTrue(status == 201 || status == 403, 
                             "CSRF protection should be properly configured");
                });

        // Test 2: Business Logic Flaws
        // Attempt to join same hive multiple times
        UUID hiveId = UUID.randomUUID();
        
        mockMvc.perform(post("/api/v1/hives/" + hiveId + "/join")
                .header("Authorization", "Bearer " + validUserToken)
                .contentType(MediaType.APPLICATION_JSON)
                .content("{}"))
                .andExpected(status().isOk());

        // Second attempt should be handled gracefully
        mockMvc.perform(post("/api/v1/hives/" + hiveId + "/join")
                .header("Authorization", "Bearer " + validUserToken)
                .contentType(MediaType.APPLICATION_JSON)
                .content("{}"))
                .andExpected(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status == 200 || status == 409, 
                             "Should handle duplicate joins gracefully");
                });

        // Test 3: Race Condition Prevention
        AtomicInteger successCount = new AtomicInteger(0);
        
        // Simulate concurrent operations
        SecurityTestUtils.simulateConcurrentRequests(() -> {
            try {
                MvcResult result = mockMvc.perform(post("/api/v1/hives")
                        .header("Authorization", "Bearer " + validUserToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"name\":\"Race Test Hive " + System.nanoTime() + "\"}"))
                        .andReturn();
                
                if (result.getResponse().getStatus() == 201) {
                    successCount.incrementAndGet();
                }
            } catch (Exception e) {
                // Expected for some concurrent requests
            }
        }, 5, 10);

        // Should handle concurrent requests without corruption
        assertTrue(successCount.get() >= 0, "Should handle concurrent requests safely");
    }

    // ============== A05:2021 – Security Misconfiguration ==============

    @Test
    @Order(7)
    @DisplayName("A05: Should prevent security misconfiguration")
    void testSecurityMisconfiguration() throws Exception {
        // Test 1: Default credentials
        List<String> defaultCredentials = Arrays.asList(
            "admin:admin",
            "admin:password",
            "root:root",
            "administrator:password",
            "guest:guest"
        );

        for (String creds : defaultCredentials) {
            String[] parts = creds.split(":");
            Map<String, String> loginRequest = Map.of(
                "username", parts[0],
                "password", parts[1]
            );

            mockMvc.perform(post("/api/v1/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(SecurityTestUtils.toJson(loginRequest)))
                    .andExpected(status().isUnauthorized());
        }

        // Test 2: Directory traversal
        List<String> pathTraversalPayloads = SecurityTestUtils.getPathTraversalPayloads();
        
        for (String payload : pathTraversalPayloads) {
            mockMvc.perform(get("/api/v1/files/" + payload)
                    .header("Authorization", "Bearer " + validUserToken))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        String response = result.getResponse().getContentAsString();
                        
                        // Should not serve system files
                        assertTrue(status >= 400 || status == 404, 
                                 "Path traversal should be blocked");
                        if (status < 400) {
                            assertFalse(response.contains("root:x:"), 
                                       "Should not serve /etc/passwd");
                            assertFalse(response.contains("[users]"), 
                                       "Should not serve system config files");
                        }
                    });
        }

        // Test 3: Debug information exposure
        mockMvc.perform(get("/api/v1/debug")
                .header("Authorization", "Bearer " + validUserToken))
                .andExpected(status().isNotFound()); // Should not exist

        // Test 4: Stack trace exposure
        mockMvc.perform(post("/api/v1/hives")
                .header("Authorization", "Bearer " + "invalid.jwt.token")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"invalid\":\"data\"}"))
                .andExpected(result -> {
                    String response = result.getResponse().getContentAsString();
                    assertFalse(response.contains("java.lang"), 
                               "Should not expose stack traces");
                    assertFalse(response.contains("at com.focushive"), 
                               "Should not expose internal class names");
                });
    }

    // ============== A06:2021 – Vulnerable and Outdated Components ==============

    @Test
    @Order(8)
    @DisplayName("A06: Should identify vulnerable components")
    void testVulnerableComponents() throws Exception {
        // This test would typically integrate with dependency scanning tools
        // For now, we'll test that known vulnerable endpoints don't exist
        
        // Test for known vulnerable Spring endpoints
        List<String> vulnerableEndpoints = Arrays.asList(
            "/actuator/env",
            "/actuator/configprops", 
            "/actuator/beans",
            "/actuator/mappings",
            "/trace",
            "/dump",
            "/autoconfig"
        );

        for (String endpoint : vulnerableEndpoints) {
            mockMvc.perform(get(endpoint))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status == 401 || status == 403 || status == 404,
                                 "Sensitive actuator endpoint should be protected: " + endpoint);
                    });
        }

        // Test that only safe actuator endpoints are exposed
        mockMvc.perform(get("/actuator/health"))
                .andExpected(status().isOk()); // Health endpoint is typically safe

        mockMvc.perform(get("/actuator/info"))
                .andExpected(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status == 200 || status == 404, 
                             "Info endpoint should be safe or disabled");
                });
    }

    // ============== A07:2021 – Identification and Authentication Failures ==============

    @Test
    @Order(9)
    @DisplayName("A07: Should prevent authentication failures")
    void testAuthenticationFailures() throws Exception {
        // Test 1: Brute force protection
        String username = "bruteforce_target";
        
        for (int i = 0; i < 10; i++) {
            Map<String, String> loginRequest = Map.of(
                "username", username,
                "password", "wrong_password_" + i
            );

            MvcResult result = mockMvc.perform(post("/api/v1/auth/login")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(SecurityTestUtils.toJson(loginRequest)))
                    .andReturn();

            // After several attempts, should be rate limited
            if (i > 5) {
                int status = result.getResponse().getStatus();
                assertTrue(status == 429 || status == 401, 
                         "Should implement rate limiting after failed attempts");
            }
        }

        // Test 2: Weak password acceptance
        List<String> weakPasswords = Arrays.asList(
            "password",
            "123456",
            "qwerty",
            "abc123"
        );

        for (String weakPassword : weakPasswords) {
            Map<String, Object> userRegistration = Map.of(
                "username", "weakpwdtest" + weakPassword.hashCode(),
                "email", "weak@test.com",
                "password", weakPassword
            );

            mockMvc.perform(post("/api/v1/auth/register")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(SecurityTestUtils.toJson(userRegistration)))
                    .andExpected(status().isBadRequest())
                    .andExpected(jsonPath("$.error").exists());
        }

        // Test 3: Session fixation
        // Get initial session
        MvcResult initialResult = mockMvc.perform(get("/api/v1/auth/session"))
                .andReturn();
        
        String initialSessionId = extractSessionId(initialResult);

        // Login
        Map<String, String> loginRequest = Map.of(
            "username", "testuser",
            "password", "ValidPassword123!"
        );

        MvcResult loginResult = mockMvc.perform(post("/api/v1/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content(SecurityTestUtils.toJson(loginRequest)))
                .andReturn();

        String postLoginSessionId = extractSessionId(loginResult);

        // Session ID should change after login (if using sessions)
        if (initialSessionId != null && postLoginSessionId != null) {
            assertNotEquals(initialSessionId, postLoginSessionId, 
                           "Session ID should change after authentication");
        }
    }

    // ============== A08:2021 – Software and Data Integrity Failures ==============

    @Test
    @Order(10)
    @DisplayName("A08: Should prevent integrity failures")
    void testIntegrityFailures() throws Exception {
        // Test 1: Unsigned/unverified software updates
        // (This would be tested in CI/CD pipeline integration)
        
        // Test 2: Insecure deserialization
        String maliciousPayload = "rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5jb21wYXJhdG9ycy5UcmFuc2Zvcm1pbmdDb21wYXJhdG9y";
        
        mockMvc.perform(post("/api/v1/import/serialized")
                .header("Authorization", "Bearer " + validUserToken)
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"data\":\"" + maliciousPayload + "\"}"))
                .andExpected(result -> {
                    int status = result.getResponse().getStatus();
                    assertTrue(status >= 400, 
                             "Should reject potentially malicious serialized data");
                });

        // Test 3: Data integrity checks
        Map<String, Object> dataWithChecksum = Map.of(
            "data", "important user data",
            "checksum", "invalid_checksum"
        );

        mockMvc.perform(post("/api/v1/data/secure-upload")
                .header("Authorization", "Bearer " + validUserToken)
                .contentType(MediaType.APPLICATION_JSON)
                .content(SecurityTestUtils.toJson(dataWithChecksum)))
                .andExpected(result -> {
                    int status = result.getResponse().getStatus();
                    if (status < 400) {
                        // If endpoint exists, it should validate checksums
                        String response = result.getResponse().getContentAsString();
                        assertTrue(response.contains("error") || response.contains("invalid"), 
                                 "Should validate data integrity");
                    }
                });
    }

    // ============== A09:2021 – Security Logging and Monitoring Failures ==============

    @Test
    @Order(11)
    @DisplayName("A09: Should implement proper security logging")
    void testSecurityLogging() throws Exception {
        // Test 1: Failed login logging
        Map<String, String> failedLogin = Map.of(
            "username", "attacker",
            "password", "wrongpassword"
        );

        mockMvc.perform(post("/api/v1/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content(SecurityTestUtils.toJson(failedLogin)))
                .andExpected(status().isUnauthorized());

        // Test 2: Successful login logging
        Map<String, String> successfulLogin = Map.of(
            "username", "testuser",
            "password", "correctpassword"
        );

        mockMvc.perform(post("/api/v1/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content(SecurityTestUtils.toJson(successfulLogin)))
                .andExpected(result -> {
                    // Should log successful authentication
                    assertTrue(result.getResponse().getStatus() <= 400, 
                             "Should handle authentication attempts");
                });

        // Test 3: Privilege escalation attempt logging
        mockMvc.perform(get("/api/v1/admin/users")
                .header("Authorization", "Bearer " + validUserToken))
                .andExpected(status().isForbidden());

        // Test 4: Data access logging
        mockMvc.perform(get("/api/v1/users/profile")
                .header("Authorization", "Bearer " + validUserToken))
                .andExpected(status().isOk());

        // In real implementation, you would verify logs contain:
        // - Timestamp
        // - User identity
        // - Action attempted
        // - IP address
        // - User agent
        // - Outcome (success/failure)
    }

    // ============== A10:2021 – Server-Side Request Forgery (SSRF) ==============

    @Test
    @Order(12)
    @DisplayName("A10: Should prevent SSRF attacks")
    void testSSRFPrevention() throws Exception {
        // Test 1: Internal network access attempts
        List<String> ssrfPayloads = Arrays.asList(
            "http://localhost:8080/admin",
            "http://127.0.0.1:22",
            "http://192.168.1.1/admin",
            "http://169.254.169.254/latest/meta-data",
            "file:///etc/passwd",
            "ftp://internal.server/sensitive",
            "http://internal-service:8080/secret"
        );

        for (String payload : ssrfPayloads) {
            // Test URL fetching endpoints
            mockMvc.perform(post("/api/v1/webhook/test")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content("{\"url\":\"" + payload + "\"}"))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        String response = result.getResponse().getContentAsString();
                        
                        // Should block internal network access
                        assertTrue(status >= 400, "Should block SSRF attempt: " + payload);
                        if (status < 400) {
                            assertFalse(response.contains("root:"), 
                                       "Should not return internal file contents");
                            assertFalse(response.contains("AWS_"), 
                                       "Should not return cloud metadata");
                        }
                    });

            // Test image upload with URL
            mockMvc.perform(post("/api/v1/users/avatar/url")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content("{\"imageUrl\":\"" + payload + "\"}"))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status >= 400 || status == 422, 
                                 "Should validate image URLs against SSRF");
                    });
        }

        // Test 2: URL validation bypass attempts
        List<String> bypassAttempts = Arrays.asList(
            "http://evil.com@localhost:8080/",
            "http://localhost#.evil.com/",
            "http://127.000.000.1:8080/",
            "http://[::1]:8080/",
            "http://2130706433:8080/" // 127.0.0.1 in decimal
        );

        for (String bypass : bypassAttempts) {
            mockMvc.perform(post("/api/v1/webhook/test")
                    .header("Authorization", "Bearer " + validUserToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content("{\"url\":\"" + bypass + "\"}"))
                    .andExpected(result -> {
                        int status = result.getResponse().getStatus();
                        assertTrue(status >= 400, 
                                 "Should prevent SSRF bypass attempt: " + bypass);
                    });
        }
    }

    // ============== Helper Methods ==============

    private String extractSessionId(MvcResult result) {
        String setCookieHeader = result.getResponse().getHeader("Set-Cookie");
        if (setCookieHeader != null && setCookieHeader.contains("JSESSIONID")) {
            int start = setCookieHeader.indexOf("JSESSIONID=") + "JSESSIONID=".length();
            int end = setCookieHeader.indexOf(";", start);
            if (end == -1) end = setCookieHeader.length();
            return setCookieHeader.substring(start, end);
        }
        return null;
    }
}